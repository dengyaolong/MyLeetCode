# 题意
给定一个整数数组，每次可以将n - 1个元素 + 1, 问最快多少次另数组每个元素都相等

比如 (1, 2, 3) :

(2,3,3) => (3,4,3) => (4,4,4)

# 解法
这道题看似容易，实则我想了很久...

明显最优策略是：选择前n - 1小的元素增加，直到原来最小的等于原来最大的。这时候最大的值就发生改变了...如此直到所有元素相等

明显：其实前n-1操作次数明显是： max - min..

注意两点：一、我们没必要每次排序，二、没必要真的加

解析一下：

一是因为每次都是上一轮的最大值变成最小值，第二大的变成最大。其实就是pop一下，再进行unshift操作

二是因为操作次数 = max - min 
= (上一轮第二大的 + 上一轮的max' - min') - (上一轮的max')
= 上一轮第二大的 + 上一轮的min'

讲得也挺绕的，看代码会好一些

