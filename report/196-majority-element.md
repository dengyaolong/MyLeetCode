# 题意
给定一个n长数字数组, 其中有一个数字出现超过Math.floor(n / 2)次, 找出这个数.
比如[1,2,2], 返回2

# 解法

## hash
这个想法最容易想了,从左到右遍历, hash[num]++, 如果超过n/2就返回. 空间复杂度o(n)

## 更有趣的想法
因为只有一个数超过n/2次.所以我们用动态规划的想法来看. 

我们用一个major记录当前出现最多次. cnt表示出现次数.

首先major = nums[0], cnt = 1. 

从左到右遍历
* 如果cnt == 0, major就要更新了, cnt重置为1
* 如果nums[i] === major, 则cnt+1
* 否则nums[i] !== major, **这时cnt - 1**. 

大家认真想, 此消彼长, 最后留下的肯定是出现超过n/2的数字.
