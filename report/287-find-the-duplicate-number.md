# 题意
给定一个n + 1长数组，所有元素都是1~n的整数。其中有且只有一个是出现大于1次的数。请找出该数。

注意：

* 不允许修改array(意思就是sort不能用了)
* 只能用O(1)空间复杂度
* 小于O(n^2)时间复杂度

# 解法

## 我觉得我写了一个O(n^2)
大概思路就是，t | nums[i] === t，证明这个数有可能出现过。之后就可以走一遍循环比较了。low...但是过掉了

## 映射找环法
注意一点：数组是n+1长的，数字是1-n。我们如果进行i=0开始，i=a[i]这样迭代。肯定会出现loop，这个loop的起点就是我们要找的数字, 记该点为O。整个形状大概就是链条+环\_O (简直灵魂画手....)

比如[1,3,4,2,2], 会迭代出[0,1,3,2,4,2,4,2,4,...], 这里就是2,4形成了循环。 

现在我们使用两个指针，一个是fast, 一个是slow。fast = a[a[fast]], slow = a[slow]. 当slow和fast相遇时候, **肯定是在环中的**, 记交点为P, 原点记做S。

因为fast为两倍slow速度。所以fast=2 * (SO + OP) , 同时fast = SO + OP + OO, 所以OO = SO + OP， SO = OO - OP = PO, 及从P开始，和从原点S出发，相遇的就是我们要找的目标点O。

所以从P出发，和从S出发，同速迭代到相遇，就可以得到结果了.
