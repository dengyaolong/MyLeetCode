# 题意
给定一个数组，一个数字S，可以通过+, -来组合这些数，求有多少个组合使得和=Ｓ

注意：

* 数组长度不超过20
* 结果不超过32位

# 解法

## 暴力模拟(超时)
这道题我一开始看有些懵，大概算了一下2^20次方也不大，也就100万，按道理dfs＋剪纸应该是能行的.试了一遍，超时了....跑到45个test


## 二分+hash(200ms) 
后来我想了一下，可以通过分成两端求和，一边用hash，空间换时间．

这时候最多2^10求出前半段所有可能和，通过hashMap建立数=>组合次数

再最多2^10次方求出后半段所有可能和，通过查找S - secondPart是否存在前半段的hashMap，就可以得到结果了

当然是AC了.

# 其实这是一道dp

我们换个思路，首先全部取符号-，

为了使 -sum(arr) = S 

我们需要调整若干个-转化为+号，使得 -sum(arr) + 2 * sum(subArr)  = S 

即： 2 * sum(subArr) = S + sum(arr)

也就是找出subArr得到 (S+sum(arr)) / 2

整个状态方程就是：

```
dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]
dp[0][0] = 1
```

i指的是前i个数，j指的是组合和，可以理解为：

```
每一个dp[i][j] = 不选择nums[i]凑出j + 选择nums[i]凑出j
               = dp[i - 1][j] + dp[i - 1][j - nums[i]]

初始状态则是，0个数凑成0，所以是1
```

## 进一步优化
如果j从后往前遍历，那其实i是可以省略的。

```
dp[0] = 1
dp[1...S] = 0

i: 0 -> nums.length
    j: V -> nums[i]
        dp[j] += dp[j - nums[i]]
```
